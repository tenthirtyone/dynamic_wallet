'use strict';

var viem = require('viem');
var accounts = require('viem/accounts');
var http = require('@turnkey/http');
var apiKeyStamper = require('@turnkey/api-key-stamper');

async function createAccount(input) {
    const { client, organizationId, signWith } = input;
    let { ethereumAddress } = input;
    if (!signWith) {
        throw new http.TurnkeyActivityError({
            message: `Missing signWith parameter`,
        });
    }
    if (viem.isAddress(signWith)) {
        // override provided `ethereumAddress`
        ethereumAddress = signWith;
    }
    else if (!ethereumAddress) {
        // we have a private key ID, but not an ethereumAddress
        const data = await client.getPrivateKey({
            privateKeyId: signWith,
            organizationId: organizationId,
        });
        ethereumAddress = data.privateKey.addresses.find((item) => item.format === "ADDRESS_FORMAT_ETHEREUM")?.address;
        if (typeof ethereumAddress !== "string" || !ethereumAddress) {
            throw new http.TurnkeyActivityError({
                message: `Unable to find Ethereum address for key ${signWith} under organization ${organizationId}`,
            });
        }
    }
    return accounts.toAccount({
        address: ethereumAddress,
        signMessage: function ({ message, }) {
            return signMessage(client, message, organizationId, signWith);
        },
        signTransaction: function (transaction, args) {
            const serializer = !args?.serializer
                ? viem.serializeTransaction
                : args.serializer;
            return signTransaction(client, transaction, serializer, organizationId, signWith);
        },
        signTypedData: function (typedData) {
            return signTypedData(client, typedData, organizationId, signWith);
        },
    });
}
/**
 * Creates a new Custom Account backed by a Turnkey API key.
 * @deprecated use {@link createAccount} instead.
 */
async function createApiKeyAccount(config) {
    const { apiPublicKey, apiPrivateKey, baseUrl, organizationId, privateKeyId } = config;
    const stamper = new apiKeyStamper.ApiKeyStamper({
        apiPublicKey: apiPublicKey,
        apiPrivateKey: apiPrivateKey,
    });
    const client = new http.TurnkeyClient({
        baseUrl: baseUrl,
    }, stamper);
    const data = await client.getPrivateKey({
        privateKeyId: privateKeyId,
        organizationId: organizationId,
    });
    const ethereumAddress = data.privateKey.addresses.find((item) => item.format === "ADDRESS_FORMAT_ETHEREUM")?.address;
    if (typeof ethereumAddress !== "string" || !ethereumAddress) {
        throw new http.TurnkeyActivityError({
            message: `Unable to find Ethereum address for key ${privateKeyId} under organization ${organizationId}`,
        });
    }
    return accounts.toAccount({
        address: ethereumAddress,
        signMessage: function ({ message, }) {
            return signMessage(client, message, organizationId, privateKeyId);
        },
        signTransaction: function (transaction, args) {
            const serializer = !args?.serializer
                ? viem.serializeTransaction
                : args.serializer;
            return signTransaction(client, transaction, serializer, organizationId, privateKeyId);
        },
        signTypedData: function (typedData) {
            return signTypedData(client, typedData, organizationId, privateKeyId);
        },
    });
}
async function signMessage(client, message, organizationId, signWith) {
    const hashedMessage = viem.hashMessage(message);
    const signedMessage = await signMessageWithErrorWrapping(client, hashedMessage, organizationId, signWith);
    return `${signedMessage}`;
}
async function signTransaction(client, transaction, serializer, organizationId, signWith) {
    const serializedTx = serializer(transaction);
    const nonHexPrefixedSerializedTx = serializedTx.replace(/^0x/, "");
    return await signTransactionWithErrorWrapping(client, nonHexPrefixedSerializedTx, organizationId, signWith);
}
async function signTypedData(client, data, organizationId, signWith) {
    const hashToSign = viem.hashTypedData(data);
    return await signMessageWithErrorWrapping(client, hashToSign, organizationId, signWith);
}
async function signTransactionWithErrorWrapping(client, unsignedTransaction, organizationId, signWith) {
    let signedTx;
    try {
        signedTx = await signTransactionImpl(client, unsignedTransaction, organizationId, signWith);
    }
    catch (error) {
        if (error instanceof http.TurnkeyActivityError) {
            throw error;
        }
        throw new http.TurnkeyActivityError({
            message: `Failed to sign transaction: ${error.message}`,
            cause: error,
        });
    }
    return `0x${signedTx}`;
}
async function signTransactionImpl(client, unsignedTransaction, organizationId, signWith) {
    const { activity } = await client.signTransaction({
        type: "ACTIVITY_TYPE_SIGN_TRANSACTION_V2",
        organizationId: organizationId,
        parameters: {
            signWith,
            type: "TRANSACTION_TYPE_ETHEREUM",
            unsignedTransaction: unsignedTransaction,
        },
        timestampMs: String(Date.now()), // millisecond timestamp
    });
    const { id, status, type } = activity;
    if (activity.status === "ACTIVITY_STATUS_COMPLETED") {
        return assertNonNull(activity?.result?.signTransactionResult?.signedTransaction);
    }
    throw new http.TurnkeyActivityError({
        message: `Invalid activity status: ${activity.status}`,
        activityId: id,
        activityStatus: status,
        activityType: type,
    });
}
async function signMessageWithErrorWrapping(client, message, organizationId, signWith) {
    let signedMessage;
    try {
        signedMessage = await signMessageImpl(client, message, organizationId, signWith);
    }
    catch (error) {
        if (error instanceof http.TurnkeyActivityError) {
            throw error;
        }
        throw new http.TurnkeyActivityError({
            message: `Failed to sign: ${error.message}`,
            cause: error,
        });
    }
    return signedMessage;
}
async function signMessageImpl(client, message, organizationId, signWith) {
    const { activity } = await client.signRawPayload({
        type: "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2",
        organizationId: organizationId,
        parameters: {
            signWith,
            payload: message,
            encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
            hashFunction: "HASH_FUNCTION_NO_OP",
        },
        timestampMs: String(Date.now()), // millisecond timestamp
    });
    const { id, status, type } = activity;
    if (activity.status === "ACTIVITY_STATUS_COMPLETED") {
        let result = assertNonNull(activity?.result?.signRawPayloadResult);
        let assembled = viem.signatureToHex({
            r: `0x${result.r}`,
            s: `0x${result.s}`,
            v: result.v === "00" ? 27n : 28n,
        });
        // Assemble the hex
        return assertNonNull(assembled);
    }
    throw new http.TurnkeyActivityError({
        message: `Invalid activity status: ${activity.status}`,
        activityId: id,
        activityStatus: status,
        activityType: type,
    });
}
function assertNonNull(input) {
    if (input == null) {
        throw new Error(`Got unexpected ${JSON.stringify(input)}`);
    }
    return input;
}

exports.createAccount = createAccount;
exports.createApiKeyAccount = createApiKeyAccount;
//# sourceMappingURL=index.js.map
