'use strict';

var web3_js = require('@solana/web3.js');
var http = require('@turnkey/http');

class TurnkeySigner {
    constructor(input) {
        this.organizationId = input.organizationId;
        this.client = input.client;
    }
    /**
     * This function takes a Solana transaction and adds a signature with Turnkey
     *
     * @param tx Transaction | VersionedTransaction object (native @solana/web3.js type)
     * @param fromAddress Solana address (base58 encoded)
     */
    async addSignature(tx, fromAddress) {
        const fromKey = new web3_js.PublicKey(fromAddress);
        let messageToSign;
        // @ts-ignore
        // type narrowing (e.g. tx instanceof Transaction) does not seem to work here when the package gets compiled
        // and bundled. Instead, we will check for the existence of a property unique to the Transaction class
        // to determine whether the caller passed a Transaction or a VersionedTransaction
        if (typeof tx.serializeMessage === "function") {
            messageToSign = tx.serializeMessage();
        }
        else {
            messageToSign = Buffer.from(tx.message.serialize());
        }
        const signRawPayloadResult = await this.signRawPayload(messageToSign.toString("hex"), fromAddress);
        const signature = `${signRawPayloadResult.signRawPayloadResult?.r}${signRawPayloadResult.signRawPayloadResult?.s}`;
        tx.addSignature(fromKey, Buffer.from(signature, "hex"));
    }
    /**
     * This function takes a message and returns it after being signed with Turnkey
     *
     * @param message The message to sign (Uint8Array)
     * @param fromAddress Solana address (base58 encoded)
     */
    async signMessage(message, fromAddress) {
        const signRawPayloadResult = await this.signRawPayload(Buffer.from(message).toString("hex"), fromAddress);
        return Buffer.from(`${signRawPayloadResult.signRawPayloadResult?.r}${signRawPayloadResult.signRawPayloadResult?.s}`, "hex");
    }
    async signRawPayload(payload, signWith) {
        const response = await this.client.signRawPayload({
            type: "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2",
            organizationId: this.organizationId,
            timestampMs: String(Date.now()),
            parameters: {
                signWith,
                payload,
                encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
                // Note: unlike ECDSA, EdDSA's API does not support signing raw digests (see RFC 8032).
                // Turnkey's signer requires an explicit value to be passed here to minimize ambiguity.
                hashFunction: "HASH_FUNCTION_NOT_APPLICABLE",
            },
        });
        const { id, status, type, result } = response.activity;
        if (status !== "ACTIVITY_STATUS_COMPLETED") {
            throw new http.TurnkeyActivityError({
                message: `Expected COMPLETED status, got ${status}`,
                activityId: id,
                activityStatus: status,
                activityType: type,
            });
        }
        return result;
    }
}

exports.TurnkeySigner = TurnkeySigner;
//# sourceMappingURL=index.js.map
