'use client'
import { __awaiter } from '../../../_virtual/_tslib.js';
import { Psbt } from 'bitcoinjs-lib';
import { BitcoinNetworkType, getAddress, AddressPurpose, signMessage, sendBtcTransaction, signTransaction } from 'sats-connect';
import { isMobile, template } from '@dynamic-labs/utils';
import { findWalletBookWallet } from '@dynamic-labs/wallet-book';
import { SATSCONNECT_FEATURE } from '../../const.js';
import '@dynamic-labs/wallet-connector-core';
import { BitcoinWalletConnector } from '../BitcoinWalletConnector.js';
import { validatePsbt } from '../../utils/psbt/validator/validatePsbt.js';
import { getSigHashType } from '../../utils/psbt/getSigHashType.js';
import { convertNetworkTypeForPsbt } from '../../utils/psbt/bitcoinNetworkTypeToNetworks.js';
import { supportsSatsConnect } from '../../utils/supportsSatsConnect.js';

class BitcoinSatsConnectConnector extends BitcoinWalletConnector {
    constructor(opts) {
        super(opts);
        this.currentNetwork = BitcoinNetworkType.Mainnet;
        // satsconnect wallets don't support fetching connected accounts without prompting
        // for a connection, so we handle getConnectedAccounts differently.
        this.canFetchConnectedAccounts = false;
    }
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            // xverse doesn't support wallet standard, so we won't have a wallet object,
            // but it's already the default provider for sats-connect, so it's ok
            // for getProvider in getAddress to return undefined
            // if we're not using xverse, we need to check if there is a wallet and
            // that it has the satsconnect feature to return the correct provider to use
            if (!supportsSatsConnect(this)) {
                return;
            }
            const wallet = findWalletBookWallet(this.walletBook, this.key);
            const inAppBrowserUrl = (_a = wallet === null || wallet === void 0 ? void 0 : wallet.mobile) === null || _a === void 0 ? void 0 : _a.inAppBrowser;
            if (isMobile() && !this.isInstalledOnBrowser() && inAppBrowserUrl) {
                const inAppBrowserTemplate = template(inAppBrowserUrl);
                const deepLink = inAppBrowserTemplate({
                    encodedDappURI: encodeURIComponent(window.location.toString()),
                });
                window.location.href = deepLink;
                return;
            }
            return new Promise((resolve, reject) => {
                getAddress({
                    getProvider: () => __awaiter(this, void 0, void 0, function* () {
                        var _a, _b;
                        return (_b = (_a = this.wallet) === null || _a === void 0 ? void 0 : _a.features[SATSCONNECT_FEATURE]) === null || _b === void 0 ? void 0 : _b.provider;
                    }),
                    onCancel: () => {
                        const error = new Error();
                        error.code = '-32000'; // error code for user cancelled
                        reject(error);
                    },
                    onFinish: (response) => __awaiter(this, void 0, void 0, function* () {
                        var _c;
                        const { addresses } = response;
                        const ordinalsAccount = addresses === null || addresses === void 0 ? void 0 : addresses.find((address) => address.purpose === AddressPurpose.Ordinals);
                        const paymentAccount = addresses === null || addresses === void 0 ? void 0 : addresses.find((address) => address.purpose === AddressPurpose.Payment);
                        const mainAddress = (_c = ordinalsAccount === null || ordinalsAccount === void 0 ? void 0 : ordinalsAccount.address) !== null && _c !== void 0 ? _c : paymentAccount === null || paymentAccount === void 0 ? void 0 : paymentAccount.address;
                        yield this.setConnectedAccountWithAddresses({
                            active: true,
                            mainAddress,
                            ordinalsAddress: ordinalsAccount,
                            paymentAddress: paymentAccount,
                        });
                        resolve(mainAddress);
                    }),
                    payload: {
                        message: 'Address for receiving Ordinals and payments',
                        network: {
                            type: this.currentNetwork,
                        },
                        purposes: [AddressPurpose.Ordinals, AddressPurpose.Payment],
                    },
                });
            });
        });
    }
    signMessage(messageToSign) {
        return __awaiter(this, void 0, void 0, function* () {
            const [walletAddress] = yield this.getConnectedAccounts();
            if (!walletAddress || !supportsSatsConnect(this)) {
                return;
            }
            return new Promise((resolve, reject) => {
                signMessage({
                    getProvider: () => __awaiter(this, void 0, void 0, function* () {
                        var _a, _b;
                        return (_b = (_a = this.wallet) === null || _a === void 0 ? void 0 : _a.features[SATSCONNECT_FEATURE]) === null || _b === void 0 ? void 0 : _b.provider;
                    }),
                    onCancel: () => {
                        const error = new Error();
                        error.code = '-32000'; // error code for user cancelled
                        reject(error);
                    },
                    onFinish: (response) => __awaiter(this, void 0, void 0, function* () {
                        if (this.isHardwareWalletEnabled) {
                            return resolve(JSON.stringify({
                                signedTransaction: {
                                    data: response,
                                },
                            }));
                        }
                        resolve(response);
                    }),
                    payload: {
                        address: walletAddress,
                        message: messageToSign,
                        network: {
                            type: this.currentNetwork,
                        },
                    },
                });
            });
        });
    }
    sendBitcoin(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const mainAddress = yield this.getAddress();
            const senderAddress = (_a = (yield this.getAdditionalAddresses(mainAddress)).find((address) => address.type === 'payment')) === null || _a === void 0 ? void 0 : _a.address;
            if (!senderAddress || !supportsSatsConnect(this)) {
                return;
            }
            return new Promise((resolve, reject) => {
                sendBtcTransaction({
                    getProvider: () => __awaiter(this, void 0, void 0, function* () {
                        var _a, _b;
                        return (_b = (_a = this.wallet) === null || _a === void 0 ? void 0 : _a.features[SATSCONNECT_FEATURE]) === null || _b === void 0 ? void 0 : _b.provider;
                    }),
                    onCancel: () => {
                        const error = new Error();
                        error.code = '-32000'; // error code for user cancelled
                        reject(error);
                    },
                    onFinish: (response) => {
                        resolve(response);
                    },
                    payload: {
                        network: {
                            type: this.currentNetwork,
                        },
                        recipients: [
                            {
                                address: transaction.recipientAddress,
                                amountSats: transaction.amount,
                            },
                        ],
                        senderAddress,
                    },
                });
            });
        });
    }
    signTransaction(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const { message, psbtBase64, broadcast, inputsToSign } = params;
            return new Promise((resolve, reject) => {
                signTransaction({
                    getProvider: () => __awaiter(this, void 0, void 0, function* () {
                        var _a, _b;
                        return (_b = (_a = this.wallet) === null || _a === void 0 ? void 0 : _a.features[SATSCONNECT_FEATURE]) === null || _b === void 0 ? void 0 : _b.provider;
                    }),
                    onCancel: () => {
                        const error = new Error();
                        error.code = '-32000'; // error code for user cancelled
                        reject(error);
                    },
                    onFinish: (response) => {
                        resolve(response);
                    },
                    payload: {
                        broadcast,
                        inputsToSign,
                        message: message || 'Sign Transaction',
                        network: {
                            type: this.currentNetwork,
                        },
                        psbtBase64,
                    },
                });
            });
        });
    }
    signPsbt(request) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            if (!((_a = request.allowedSighash) === null || _a === void 0 ? void 0 : _a.length))
                throw new Error('allowedSighash cannot be an empty array');
            const network = convertNetworkTypeForPsbt(this.currentNetwork);
            const psbtFromBase64 = Psbt.fromBase64(request.unsignedPsbtBase64, {
                network,
            });
            if ((_b = request.signature) === null || _b === void 0 ? void 0 : _b.length) {
                validatePsbt(psbtFromBase64, request.allowedSighash, request.signature);
            }
            const inputsToSign = ((_d = (_c = request.signature) === null || _c === void 0 ? void 0 : _c.map((sig) => {
                var _a;
                return ((_a = sig.signingIndexes) !== null && _a !== void 0 ? _a : []).map((inputIndex) => ({
                    address: sig.address,
                    sigHash: getSigHashType(psbtFromBase64.data.inputs[inputIndex]),
                    signingIndexes: [inputIndex],
                }));
            })) !== null && _d !== void 0 ? _d : []).flat();
            const signedPsbt = yield this.signTransaction({
                broadcast: false,
                inputsToSign,
                psbtBase64: request.unsignedPsbtBase64,
            });
            if (!signedPsbt) {
                throw new Error('Failed to sign transaction with sats-connect');
            }
            return { signedPsbt: signedPsbt.psbtBase64 };
        });
    }
}

export { BitcoinSatsConnectConnector };
