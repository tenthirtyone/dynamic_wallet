'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../../_virtual/_tslib.cjs');
var bitcoinjsLib = require('bitcoinjs-lib');
var satsConnect = require('sats-connect');
var utils = require('@dynamic-labs/utils');
var walletBook = require('@dynamic-labs/wallet-book');
var _const = require('../../const.cjs');
require('@dynamic-labs/wallet-connector-core');
var BitcoinWalletConnector = require('../BitcoinWalletConnector.cjs');
var validatePsbt = require('../../utils/psbt/validator/validatePsbt.cjs');
var getSigHashType = require('../../utils/psbt/getSigHashType.cjs');
var bitcoinNetworkTypeToNetworks = require('../../utils/psbt/bitcoinNetworkTypeToNetworks.cjs');
var supportsSatsConnect = require('../../utils/supportsSatsConnect.cjs');

class BitcoinSatsConnectConnector extends BitcoinWalletConnector.BitcoinWalletConnector {
    constructor(opts) {
        super(opts);
        this.currentNetwork = satsConnect.BitcoinNetworkType.Mainnet;
        // satsconnect wallets don't support fetching connected accounts without prompting
        // for a connection, so we handle getConnectedAccounts differently.
        this.canFetchConnectedAccounts = false;
    }
    getAddress() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            var _a;
            // xverse doesn't support wallet standard, so we won't have a wallet object,
            // but it's already the default provider for sats-connect, so it's ok
            // for getProvider in getAddress to return undefined
            // if we're not using xverse, we need to check if there is a wallet and
            // that it has the satsconnect feature to return the correct provider to use
            if (!supportsSatsConnect.supportsSatsConnect(this)) {
                return;
            }
            const wallet = walletBook.findWalletBookWallet(this.walletBook, this.key);
            const inAppBrowserUrl = (_a = wallet === null || wallet === void 0 ? void 0 : wallet.mobile) === null || _a === void 0 ? void 0 : _a.inAppBrowser;
            if (utils.isMobile() && !this.isInstalledOnBrowser() && inAppBrowserUrl) {
                const inAppBrowserTemplate = utils.template(inAppBrowserUrl);
                const deepLink = inAppBrowserTemplate({
                    encodedDappURI: encodeURIComponent(window.location.toString()),
                });
                window.location.href = deepLink;
                return;
            }
            return new Promise((resolve, reject) => {
                satsConnect.getAddress({
                    getProvider: () => _tslib.__awaiter(this, void 0, void 0, function* () {
                        var _a, _b;
                        return (_b = (_a = this.wallet) === null || _a === void 0 ? void 0 : _a.features[_const.SATSCONNECT_FEATURE]) === null || _b === void 0 ? void 0 : _b.provider;
                    }),
                    onCancel: () => {
                        const error = new Error();
                        error.code = '-32000'; // error code for user cancelled
                        reject(error);
                    },
                    onFinish: (response) => _tslib.__awaiter(this, void 0, void 0, function* () {
                        var _c;
                        const { addresses } = response;
                        const ordinalsAccount = addresses === null || addresses === void 0 ? void 0 : addresses.find((address) => address.purpose === satsConnect.AddressPurpose.Ordinals);
                        const paymentAccount = addresses === null || addresses === void 0 ? void 0 : addresses.find((address) => address.purpose === satsConnect.AddressPurpose.Payment);
                        const mainAddress = (_c = ordinalsAccount === null || ordinalsAccount === void 0 ? void 0 : ordinalsAccount.address) !== null && _c !== void 0 ? _c : paymentAccount === null || paymentAccount === void 0 ? void 0 : paymentAccount.address;
                        yield this.setConnectedAccountWithAddresses({
                            active: true,
                            mainAddress,
                            ordinalsAddress: ordinalsAccount,
                            paymentAddress: paymentAccount,
                        });
                        resolve(mainAddress);
                    }),
                    payload: {
                        message: 'Address for receiving Ordinals and payments',
                        network: {
                            type: this.currentNetwork,
                        },
                        purposes: [satsConnect.AddressPurpose.Ordinals, satsConnect.AddressPurpose.Payment],
                    },
                });
            });
        });
    }
    signMessage(messageToSign) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const [walletAddress] = yield this.getConnectedAccounts();
            if (!walletAddress || !supportsSatsConnect.supportsSatsConnect(this)) {
                return;
            }
            return new Promise((resolve, reject) => {
                satsConnect.signMessage({
                    getProvider: () => _tslib.__awaiter(this, void 0, void 0, function* () {
                        var _a, _b;
                        return (_b = (_a = this.wallet) === null || _a === void 0 ? void 0 : _a.features[_const.SATSCONNECT_FEATURE]) === null || _b === void 0 ? void 0 : _b.provider;
                    }),
                    onCancel: () => {
                        const error = new Error();
                        error.code = '-32000'; // error code for user cancelled
                        reject(error);
                    },
                    onFinish: (response) => _tslib.__awaiter(this, void 0, void 0, function* () {
                        if (this.isHardwareWalletEnabled) {
                            return resolve(JSON.stringify({
                                signedTransaction: {
                                    data: response,
                                },
                            }));
                        }
                        resolve(response);
                    }),
                    payload: {
                        address: walletAddress,
                        message: messageToSign,
                        network: {
                            type: this.currentNetwork,
                        },
                    },
                });
            });
        });
    }
    sendBitcoin(transaction) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            var _a;
            const mainAddress = yield this.getAddress();
            const senderAddress = (_a = (yield this.getAdditionalAddresses(mainAddress)).find((address) => address.type === 'payment')) === null || _a === void 0 ? void 0 : _a.address;
            if (!senderAddress || !supportsSatsConnect.supportsSatsConnect(this)) {
                return;
            }
            return new Promise((resolve, reject) => {
                satsConnect.sendBtcTransaction({
                    getProvider: () => _tslib.__awaiter(this, void 0, void 0, function* () {
                        var _a, _b;
                        return (_b = (_a = this.wallet) === null || _a === void 0 ? void 0 : _a.features[_const.SATSCONNECT_FEATURE]) === null || _b === void 0 ? void 0 : _b.provider;
                    }),
                    onCancel: () => {
                        const error = new Error();
                        error.code = '-32000'; // error code for user cancelled
                        reject(error);
                    },
                    onFinish: (response) => {
                        resolve(response);
                    },
                    payload: {
                        network: {
                            type: this.currentNetwork,
                        },
                        recipients: [
                            {
                                address: transaction.recipientAddress,
                                amountSats: transaction.amount,
                            },
                        ],
                        senderAddress,
                    },
                });
            });
        });
    }
    signTransaction(params) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const { message, psbtBase64, broadcast, inputsToSign } = params;
            return new Promise((resolve, reject) => {
                satsConnect.signTransaction({
                    getProvider: () => _tslib.__awaiter(this, void 0, void 0, function* () {
                        var _a, _b;
                        return (_b = (_a = this.wallet) === null || _a === void 0 ? void 0 : _a.features[_const.SATSCONNECT_FEATURE]) === null || _b === void 0 ? void 0 : _b.provider;
                    }),
                    onCancel: () => {
                        const error = new Error();
                        error.code = '-32000'; // error code for user cancelled
                        reject(error);
                    },
                    onFinish: (response) => {
                        resolve(response);
                    },
                    payload: {
                        broadcast,
                        inputsToSign,
                        message: message || 'Sign Transaction',
                        network: {
                            type: this.currentNetwork,
                        },
                        psbtBase64,
                    },
                });
            });
        });
    }
    signPsbt(request) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            if (!((_a = request.allowedSighash) === null || _a === void 0 ? void 0 : _a.length))
                throw new Error('allowedSighash cannot be an empty array');
            const network = bitcoinNetworkTypeToNetworks.convertNetworkTypeForPsbt(this.currentNetwork);
            const psbtFromBase64 = bitcoinjsLib.Psbt.fromBase64(request.unsignedPsbtBase64, {
                network,
            });
            if ((_b = request.signature) === null || _b === void 0 ? void 0 : _b.length) {
                validatePsbt.validatePsbt(psbtFromBase64, request.allowedSighash, request.signature);
            }
            const inputsToSign = ((_d = (_c = request.signature) === null || _c === void 0 ? void 0 : _c.map((sig) => {
                var _a;
                return ((_a = sig.signingIndexes) !== null && _a !== void 0 ? _a : []).map((inputIndex) => ({
                    address: sig.address,
                    sigHash: getSigHashType.getSigHashType(psbtFromBase64.data.inputs[inputIndex]),
                    signingIndexes: [inputIndex],
                }));
            })) !== null && _d !== void 0 ? _d : []).flat();
            const signedPsbt = yield this.signTransaction({
                broadcast: false,
                inputsToSign,
                psbtBase64: request.unsignedPsbtBase64,
            });
            if (!signedPsbt) {
                throw new Error('Failed to sign transaction with sats-connect');
            }
            return { signedPsbt: signedPsbt.psbtBase64 };
        });
    }
}

exports.BitcoinSatsConnectConnector = BitcoinSatsConnectConnector;
