'use client'
import { __awaiter } from '../../../_virtual/_tslib.js';
import { Psbt } from 'bitcoinjs-lib';
import { logger } from '@dynamic-labs/wallet-connector-core';
import { isMobile, handleMobileWalletRedirect } from '@dynamic-labs/utils';
import { BitcoinWalletConnector } from '../BitcoinWalletConnector.js';
import { createPsbtOptions } from '../../utils/psbt/createSignPsbtOptions.js';
import 'sats-connect';
import { sighashNumberToString } from '../../utils/psbt/sighashNumberToString.js';
import { decodeBase64, encodeBase64 } from '../../utils/base64.js';

class PhantomConnector extends BitcoinWalletConnector {
    constructor(opts) {
        super(Object.assign(Object.assign({}, opts), { overrideKey: 'phantombtc' }));
        this.name = 'Phantom';
        this.canFetchConnectedAccounts = true;
    }
    connectWithInstalledExtension() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            let paymentAccount, ordinalsAccount;
            if ((_a = this.walletMethods) === null || _a === void 0 ? void 0 : _a.connect) {
                const { accounts } = yield this.walletMethods.connect();
                const parsedAccounts = accounts.map((account) => ({
                    address: account.address,
                    publicKey: Buffer.from(account.publicKey).toString('hex'),
                }));
                [paymentAccount, ordinalsAccount] = parsedAccounts;
                // in case it only returns one account, we will use it as both payment and ordinals
                if (!ordinalsAccount) {
                    ordinalsAccount = paymentAccount;
                }
            }
            else {
                const provider = this.getProvider();
                if (!provider) {
                    return;
                }
                const accounts = yield provider.requestAccounts();
                ordinalsAccount = accounts === null || accounts === void 0 ? void 0 : accounts.find((address) => address.purpose === 'ordinals');
                paymentAccount = accounts === null || accounts === void 0 ? void 0 : accounts.find((address) => address.purpose === 'payment');
            }
            const mainAddress = (_b = ordinalsAccount === null || ordinalsAccount === void 0 ? void 0 : ordinalsAccount.address) !== null && _b !== void 0 ? _b : paymentAccount === null || paymentAccount === void 0 ? void 0 : paymentAccount.address;
            yield this.setConnectedAccountWithAddresses({
                active: true,
                mainAddress,
                ordinalsAddress: ordinalsAccount,
                paymentAddress: paymentAccount,
            });
            return mainAddress;
        });
    }
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isInstalledOnBrowser()) {
                return this.connectWithInstalledExtension();
            }
            if (isMobile()) {
                handleMobileWalletRedirect({
                    nativeLink: 'phantom://browse',
                    universalLink: 'https://phantom.app/ul/browse',
                });
            }
            return undefined;
        });
    }
    signMessage(messageToSign) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const [walletAddress] = yield this.getConnectedAccounts();
            if (!walletAddress) {
                return;
            }
            if ((_a = this.walletMethods) === null || _a === void 0 ? void 0 : _a.signMessage) {
                const [result] = yield this.walletMethods.signMessage({
                    // we need to sign with the ordinals account
                    account: { address: walletAddress },
                    message: new TextEncoder().encode(messageToSign),
                });
                return Buffer.from(result.signature).toString('base64');
            }
            else {
                const provider = this.getProvider();
                if (!provider) {
                    return;
                }
                const result = yield provider.signMessage(walletAddress, new TextEncoder().encode(messageToSign));
                return Buffer.from(result.signature).toString('base64');
            }
        });
    }
    sendBitcoin(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.debug('sendBitcoin - function not implemented', transaction);
            return undefined;
        });
    }
    signPsbt(request) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e;
            const [walletAddress] = yield this.getConnectedAccounts();
            if (!walletAddress) {
                return;
            }
            const psbtFromBase64 = Psbt.fromBase64(request.unsignedPsbtBase64);
            const psbtOptions = createPsbtOptions(psbtFromBase64, request);
            if ((_a = this.walletMethods) === null || _a === void 0 ? void 0 : _a.signTransaction) {
                const [signedPsbtHex] = yield this.walletMethods.signTransaction({
                    inputsToSign: (_c = (_b = psbtOptions.toSignInputs) === null || _b === void 0 ? void 0 : _b.map((input) => ({
                        account: { address: input.address },
                        sigHash: input.sighashTypes &&
                            sighashNumberToString(input.sighashTypes[0]),
                        signingIndexes: [input.index],
                    }))) !== null && _c !== void 0 ? _c : [],
                    psbt: decodeBase64(request.unsignedPsbtBase64),
                });
                return {
                    signedPsbt: Buffer.from(signedPsbtHex.signedPsbt).toString('base64'),
                };
            }
            else {
                const provider = this.getProvider();
                if (!provider) {
                    return;
                }
                const inputsToSign = (_e = (_d = request.signature) === null || _d === void 0 ? void 0 : _d.map((sig) => {
                    var _a;
                    return ({
                        address: sig.address,
                        sigHash: request.allowedSighash[0],
                        signingIndexes: (_a = sig.signingIndexes) !== null && _a !== void 0 ? _a : [],
                    });
                })) !== null && _e !== void 0 ? _e : [];
                const signedPsbt = yield provider.signPSBT(decodeBase64(request.unsignedPsbtBase64), {
                    inputsToSign,
                });
                return { signedPsbt: encodeBase64(Uint8Array.from(signedPsbt)) };
            }
        });
    }
}

export { PhantomConnector };
