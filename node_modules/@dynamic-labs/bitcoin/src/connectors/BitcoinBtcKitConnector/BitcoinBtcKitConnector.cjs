'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../../_virtual/_tslib.cjs');
var satsConnect = require('sats-connect');
var bitcoinjsLib = require('bitcoinjs-lib');
var walletConnectorCore = require('@dynamic-labs/wallet-connector-core');
var BitcoinWalletConnector = require('../BitcoinWalletConnector.cjs');
var validatePsbt = require('../../utils/psbt/validator/validatePsbt.cjs');
var bitcoinNetworkTypeToNetworks = require('../../utils/psbt/bitcoinNetworkTypeToNetworks.cjs');

class BitcoinBtcKitConnector extends BitcoinWalletConnector.BitcoinWalletConnector {
    constructor(opts, btcKit) {
        super(opts);
        this.currentNetwork = satsConnect.BitcoinNetworkType.Mainnet;
        this.btcKit = btcKit;
    }
    getAddress() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            var _a;
            const [connectedAccount] = yield this.getConnectedAccounts();
            if (connectedAccount) {
                return connectedAccount;
            }
            const response = yield this.btcKit.request('getAddresses', {
                types: ['p2tr', 'p2wpkh'],
            });
            if (!('result' in response)) {
                walletConnectorCore.logger.error('Fetch public address error', response);
                return undefined;
            }
            const { addresses } = response.result;
            const ordinalsAddress = addresses === null || addresses === void 0 ? void 0 : addresses.find((address) => address.type === 'p2tr');
            const paymentAddress = addresses === null || addresses === void 0 ? void 0 : addresses.find((address) => address.type === 'p2wpkh');
            const mainAddress = (_a = ordinalsAddress === null || ordinalsAddress === void 0 ? void 0 : ordinalsAddress.address) !== null && _a !== void 0 ? _a : paymentAddress === null || paymentAddress === void 0 ? void 0 : paymentAddress.address;
            yield this.setConnectedAccountWithAddresses({
                active: true,
                mainAddress,
                ordinalsAddress,
                paymentAddress,
            });
            return mainAddress;
        });
    }
    signMessage(messageToSign) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            if (!(yield this.getConnectedAccounts()).length)
                return undefined;
            const response = yield this.btcKit
                .request('signMessage', {
                message: messageToSign,
                paymentType: 'p2tr',
            })
                .catch(({ error }) => {
                throw error;
            });
            if (!('result' in response)) {
                walletConnectorCore.logger.error('Signature error', response);
                throw new Error('Failed to sign message');
            }
            const { signature } = response.result;
            if (this.isHardwareWalletEnabled) {
                return JSON.stringify({ signedTransaction: { data: signature } });
            }
            return signature;
        });
    }
    sendBitcoin(transaction) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const connectedAddress = yield this.getAddress();
            if (!connectedAddress || !this.btcKit) {
                return;
            }
            const response = yield this.btcKit.request('sendTransfer', {
                address: transaction.recipientAddress,
                amount: transaction.amount.toString(),
                network: this.convertNetworkTypeToNetworkMode(),
            });
            if (!('result' in response)) {
                walletConnectorCore.logger.error('Transaction error', response);
                throw new Error('Failed to send transaction');
            }
            return response.result.txid;
        });
    }
    convertNetworkTypeToNetworkMode() {
        return this.currentNetwork === satsConnect.BitcoinNetworkType.Mainnet
            ? 'mainnet'
            : 'testnet';
    }
    signPsbt(request) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const connectedAddress = yield this.getAddress();
            if (!connectedAddress || !this.btcKit) {
                return;
            }
            const network = bitcoinNetworkTypeToNetworks.convertNetworkTypeForPsbt(this.currentNetwork);
            const psbtFromBase64 = bitcoinjsLib.Psbt.fromBase64(request.unsignedPsbtBase64, {
                network,
            });
            if ((_a = request.signature) === null || _a === void 0 ? void 0 : _a.length) {
                validatePsbt.validatePsbt(psbtFromBase64, request.allowedSighash, request.signature);
            }
            const signPsbtRequestParams = {
                allowedSighash: request.allowedSighash,
                hex: psbtFromBase64.toHex(),
                signAtIndex: (_b = request.signature) === null || _b === void 0 ? void 0 : _b.flatMap((sig) => sig.signingIndexes).filter(Number.isInteger),
            };
            const signedPsbtResponse = (yield this.btcKit.request('signPsbt', Object.assign({ broadcast: false, network: this.convertNetworkTypeToNetworkMode() }, signPsbtRequestParams)));
            if (!signedPsbtResponse ||
                !('result' in signedPsbtResponse) ||
                !('hex' in signedPsbtResponse.result)) {
                throw new Error('signPsbt - failed to sign PSBT');
            }
            const psbtHex = signedPsbtResponse.result.hex;
            return { signedPsbt: bitcoinjsLib.Psbt.fromHex(psbtHex, { network }).toBase64() };
        });
    }
}

exports.BitcoinBtcKitConnector = BitcoinBtcKitConnector;
