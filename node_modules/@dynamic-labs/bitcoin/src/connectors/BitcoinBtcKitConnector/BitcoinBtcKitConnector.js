'use client'
import { __awaiter } from '../../../_virtual/_tslib.js';
import { BitcoinNetworkType } from 'sats-connect';
import { Psbt } from 'bitcoinjs-lib';
import { logger } from '@dynamic-labs/wallet-connector-core';
import { BitcoinWalletConnector } from '../BitcoinWalletConnector.js';
import { validatePsbt } from '../../utils/psbt/validator/validatePsbt.js';
import { convertNetworkTypeForPsbt } from '../../utils/psbt/bitcoinNetworkTypeToNetworks.js';

class BitcoinBtcKitConnector extends BitcoinWalletConnector {
    constructor(opts, btcKit) {
        super(opts);
        this.currentNetwork = BitcoinNetworkType.Mainnet;
        this.btcKit = btcKit;
    }
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const [connectedAccount] = yield this.getConnectedAccounts();
            if (connectedAccount) {
                return connectedAccount;
            }
            const response = yield this.btcKit.request('getAddresses', {
                types: ['p2tr', 'p2wpkh'],
            });
            if (!('result' in response)) {
                logger.error('Fetch public address error', response);
                return undefined;
            }
            const { addresses } = response.result;
            const ordinalsAddress = addresses === null || addresses === void 0 ? void 0 : addresses.find((address) => address.type === 'p2tr');
            const paymentAddress = addresses === null || addresses === void 0 ? void 0 : addresses.find((address) => address.type === 'p2wpkh');
            const mainAddress = (_a = ordinalsAddress === null || ordinalsAddress === void 0 ? void 0 : ordinalsAddress.address) !== null && _a !== void 0 ? _a : paymentAddress === null || paymentAddress === void 0 ? void 0 : paymentAddress.address;
            yield this.setConnectedAccountWithAddresses({
                active: true,
                mainAddress,
                ordinalsAddress,
                paymentAddress,
            });
            return mainAddress;
        });
    }
    signMessage(messageToSign) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.getConnectedAccounts()).length)
                return undefined;
            const response = yield this.btcKit
                .request('signMessage', {
                message: messageToSign,
                paymentType: 'p2tr',
            })
                .catch(({ error }) => {
                throw error;
            });
            if (!('result' in response)) {
                logger.error('Signature error', response);
                throw new Error('Failed to sign message');
            }
            const { signature } = response.result;
            if (this.isHardwareWalletEnabled) {
                return JSON.stringify({ signedTransaction: { data: signature } });
            }
            return signature;
        });
    }
    sendBitcoin(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            const connectedAddress = yield this.getAddress();
            if (!connectedAddress || !this.btcKit) {
                return;
            }
            const response = yield this.btcKit.request('sendTransfer', {
                address: transaction.recipientAddress,
                amount: transaction.amount.toString(),
                network: this.convertNetworkTypeToNetworkMode(),
            });
            if (!('result' in response)) {
                logger.error('Transaction error', response);
                throw new Error('Failed to send transaction');
            }
            return response.result.txid;
        });
    }
    convertNetworkTypeToNetworkMode() {
        return this.currentNetwork === BitcoinNetworkType.Mainnet
            ? 'mainnet'
            : 'testnet';
    }
    signPsbt(request) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const connectedAddress = yield this.getAddress();
            if (!connectedAddress || !this.btcKit) {
                return;
            }
            const network = convertNetworkTypeForPsbt(this.currentNetwork);
            const psbtFromBase64 = Psbt.fromBase64(request.unsignedPsbtBase64, {
                network,
            });
            if ((_a = request.signature) === null || _a === void 0 ? void 0 : _a.length) {
                validatePsbt(psbtFromBase64, request.allowedSighash, request.signature);
            }
            const signPsbtRequestParams = {
                allowedSighash: request.allowedSighash,
                hex: psbtFromBase64.toHex(),
                signAtIndex: (_b = request.signature) === null || _b === void 0 ? void 0 : _b.flatMap((sig) => sig.signingIndexes).filter(Number.isInteger),
            };
            const signedPsbtResponse = (yield this.btcKit.request('signPsbt', Object.assign({ broadcast: false, network: this.convertNetworkTypeToNetworkMode() }, signPsbtRequestParams)));
            if (!signedPsbtResponse ||
                !('result' in signedPsbtResponse) ||
                !('hex' in signedPsbtResponse.result)) {
                throw new Error('signPsbt - failed to sign PSBT');
            }
            const psbtHex = signedPsbtResponse.result.hex;
            return { signedPsbt: Psbt.fromHex(psbtHex, { network }).toBase64() };
        });
    }
}

export { BitcoinBtcKitConnector };
