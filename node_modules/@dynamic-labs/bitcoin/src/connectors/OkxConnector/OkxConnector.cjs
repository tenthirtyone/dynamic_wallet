'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../../_virtual/_tslib.cjs');
var bitcoinjsLib = require('bitcoinjs-lib');
var utils = require('@dynamic-labs/utils');
var BitcoinWalletConnector = require('../BitcoinWalletConnector.cjs');
var createSignPsbtOptions = require('../../utils/psbt/createSignPsbtOptions.cjs');

class OkxConnector extends BitcoinWalletConnector.BitcoinWalletConnector {
    constructor(opts) {
        super(Object.assign(Object.assign({}, opts), { overrideKey: 'okxwalletbtc' }));
        this.name = 'OKX Wallet';
        this.canFetchConnectedAccounts = false;
    }
    get walletBookWallet() {
        return this.walletBook.wallets[this.key];
    }
    getAddress() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            if (!this.isInstalledOnBrowser() &&
                utils.isMobile() &&
                this.walletBookWallet.mobile &&
                this.walletBookWallet.mobile.inAppBrowser) {
                const inAppBrowserCompiledTemplate = utils.template(this.walletBookWallet.mobile.inAppBrowser);
                const deepLink = inAppBrowserCompiledTemplate({
                    encodedDappURI: encodeURIComponent(window.location.toString()),
                });
                window.location.assign(deepLink);
                return;
            }
            const provider = this.getProvider();
            if (!provider) {
                return;
            }
            const { address, publicKey } = yield provider.connect();
            const bitcoinAddress = {
                address,
                publicKey,
            };
            yield this.setConnectedAccountWithAddresses({
                active: true,
                mainAddress: address,
                ordinalsAddress: bitcoinAddress,
            });
            return address;
        });
    }
    signMessage(messageToSign) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const provider = this.getProvider();
            if (!provider) {
                return;
            }
            return provider.signMessage(messageToSign, 'bip322-simple');
        });
    }
    sendBitcoin(transaction) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const provider = this.getProvider();
            const connectedAddress = yield this.getAddress();
            if (!connectedAddress || !provider) {
                return;
            }
            return provider.sendBitcoin(transaction.recipientAddress, transaction.amount.toString());
        });
    }
    signPsbt(request) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const provider = this.getProvider();
            if (!provider) {
                return;
            }
            const psbtFromBase64 = bitcoinjsLib.Psbt.fromBase64(request.unsignedPsbtBase64);
            const signedPsbtHex = yield provider.signPsbt(psbtFromBase64.toHex(), createSignPsbtOptions.createPsbtOptions(psbtFromBase64, request));
            return { signedPsbt: bitcoinjsLib.Psbt.fromHex(signedPsbtHex).toBase64() };
        });
    }
}

exports.OkxConnector = OkxConnector;
