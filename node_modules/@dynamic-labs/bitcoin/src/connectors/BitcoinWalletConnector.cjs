'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../_virtual/_tslib.cjs');
var satsConnect = require('sats-connect');
var walletConnectorCore = require('@dynamic-labs/wallet-connector-core');
var walletBook = require('@dynamic-labs/wallet-book');
var utils = require('@dynamic-labs/utils');
var sdkApiCore = require('@dynamic-labs/sdk-api-core');
var BitcoinLocalStorageCache = require('../BitcoinLocalStorageCache.cjs');
var bitcoinProviderHelper = require('../bitcoinProviderHelper.cjs');
var getMempoolApiUrl = require('../utils/getMempoolApiUrl.cjs');
var _const = require('../const.cjs');
var satoshisToBtc = require('../utils/satoshisToBtc/satoshisToBtc.cjs');

class BitcoinWalletConnector extends walletConnectorCore.WalletConnectorBase {
    constructor(opts) {
        var _a;
        super(opts);
        this.connectedChain = 'BTC';
        this.supportedChains = ['BTC'];
        // some wallets don't support fetching connected accounts without prompting for a connection
        this.canFetchConnectedAccounts = false;
        this.isHardwareWalletEnabled = false;
        this.verifiedCredentials = [];
        // this is the key from the wallet book entry so that we don't purely rely on the normalized name
        this.overrideKey = (_a = opts.overrideKey) !== null && _a !== void 0 ? _a : this.key;
        this.bitcoinProviderHelper = new bitcoinProviderHelper.BitcoinProviderHelper(opts.walletData || walletBook.getWalletBookWallet(this.walletBook, this.key));
        this.wallet = this.bitcoinProviderHelper.findWallet();
        if (this.wallet) {
            this.walletMethods = this.bitcoinProviderHelper.getWalletMethods(this.wallet);
        }
        this.cache = new BitcoinLocalStorageCache.BitcoinLocalStorageCache(this.overrideKey);
    }
    isSameAccountChangeRequest(to) {
        return this.lastAccountChange === to;
    }
    setLastAccountChangeRequest(to) {
        this.lastAccountChange = to;
    }
    clearConnectedAccounts() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            yield this.cache.clearConnectedAcccounts();
        });
    }
    canConnectWithHardwareWallet() {
        const wallet = walletBook.findWalletBookWallet(this.walletBook, this.key);
        if (!wallet || !wallet.hardwareWallets)
            return false;
        return wallet.hardwareWallets.includes('ledger');
    }
    isInstalledOnBrowser() {
        var _a;
        return (Boolean(this.wallet) || Boolean((_a = this.bitcoinProviderHelper) === null || _a === void 0 ? void 0 : _a.getProvider()));
    }
    getDeepLink() {
        return undefined;
    }
    endSession() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            yield Promise.all([
                this.cache.clearConnectedAcccounts(),
                this.cache.clearLastBalance(),
            ]);
        });
    }
    getBalance() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const [connectedAddress] = yield this.getConnectedAccounts();
            if (!connectedAddress) {
                throw new utils.DynamicError('getBalance - No connected address found!');
            }
            const additionalAddresses = yield this.getAdditionalAddresses(connectedAddress);
            const ordinalsAdditionalAddress = (_a = additionalAddresses.find((address) => address.type === sdkApiCore.WalletAddressType.Ordinals)) === null || _a === void 0 ? void 0 : _a.address;
            const paymentAdditionalAddress = (_b = additionalAddresses.find((address) => address.type === sdkApiCore.WalletAddressType.Payment)) === null || _b === void 0 ? void 0 : _b.address;
            // Some BTC wallet connectors only have 1 address type. when this is the case, it would always be `ordinals`
            // if a BTC walletConnector does NOT have a payment address, just use the ordinal address
            const paymentAddress = paymentAdditionalAddress !== null && paymentAdditionalAddress !== void 0 ? paymentAdditionalAddress : ordinalsAdditionalAddress;
            if (!paymentAddress) {
                throw new utils.DynamicError('getBalance - No payment address found!');
            }
            const API_URL = getMempoolApiUrl.getMempoolApiUrl(paymentAddress);
            const response = yield fetch(`${API_URL}/address/${paymentAddress}`);
            if (!response.ok) {
                // if the request fails due to rate limits, return cached value
                if (response.status === _const.HTTP_STATUS_TOO_MANY_REQUESTS) {
                    return this.cache.getLastBalance();
                }
                // new accounts not yet indexed will return a 404
                if (response.status === _const.HTTP_STATUS_NOT_FOUND) {
                    return '0';
                }
                return undefined;
            }
            const addressInfo = yield response.json();
            if (!(addressInfo === null || addressInfo === void 0 ? void 0 : addressInfo.chain_stats) || !(addressInfo === null || addressInfo === void 0 ? void 0 : addressInfo.mempool_stats)) {
                return undefined;
            }
            const confirmedBalanceInSats = Number(addressInfo.chain_stats.funded_txo_sum) -
                Number(addressInfo.chain_stats.spent_txo_sum);
            const unconfirmedBalanceInSats = Number(addressInfo.mempool_stats.funded_txo_sum) -
                Number(addressInfo.mempool_stats.spent_txo_sum);
            const balance = satoshisToBtc.satoshisToBtc(confirmedBalanceInSats + unconfirmedBalanceInSats);
            yield this.cache.setLastBalance(balance.toString());
            return balance.toString();
        });
    }
    getConnectedAccountsFromCache() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            var _a;
            const currentAccount = yield this.cache.getActiveAccount();
            const allAccounts = yield this.cache.getConnectedAccounts();
            const allConnectedAddresses = (_a = Object.keys(allAccounts || {})) !== null && _a !== void 0 ? _a : [];
            if (!(currentAccount === null || currentAccount === void 0 ? void 0 : currentAccount.address)) {
                return allConnectedAddresses;
            }
            // return all connected accounts with the current account as the first item
            return [
                currentAccount.address,
                ...allConnectedAddresses.filter((address) => address !== currentAccount.address),
            ];
        });
    }
    getConnectedAccounts() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            // some wallets like xverse don't support fetching connected accounts
            // without prompting for a connection
            // to avoid this behavior, we cache the connected accounts
            if (!this.canFetchConnectedAccounts) {
                return this.getConnectedAccountsFromCache();
            }
            // if we decide that is ok to prompt for a connection when fetching connected accounts
            // we shouldn't prompt every time we call this method (which is a lot of times)
            // so we just store in a promise and return the same promise every time
            if (!this.getAddressPromise) {
                this.getAddressPromise = this.getAddress();
            }
            let connectedAccount;
            try {
                connectedAccount = yield this.getAddressPromise;
            }
            catch (error) {
                walletConnectorCore.logger.error(`${this.key} getConnectedAccounts - error fetching connected account`);
                //don't throw error just return empty array after clearing the promise
            }
            this.getAddressPromise = undefined;
            if (!connectedAccount) {
                return [];
            }
            return [connectedAccount];
        });
    }
    getAdditionalAddresses(mainAddress) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            if (!mainAddress) {
                return [];
            }
            const currentAccount = yield this.cache.getConnectedAccount(mainAddress);
            return (currentAccount === null || currentAccount === void 0 ? void 0 : currentAccount.additionalAddresses) || [];
        });
    }
    setAdditionalAddresses(mainAddress, additionalAddresses) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            return this.cache.setConnectedAccount(mainAddress, {
                additionalAddresses,
            });
        });
    }
    sendRawTransaction(rawTransaction) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            if (!rawTransaction)
                return;
            const [connectedAddress] = yield this.getConnectedAccounts();
            if (!connectedAddress) {
                throw new utils.DynamicError('sendRawTransaction - No connected address found!');
            }
            const API_URL = getMempoolApiUrl.getMempoolApiUrl(connectedAddress);
            const response = yield fetch(`${API_URL}/tx`, {
                body: rawTransaction,
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                method: 'POST',
            });
            if (!response.ok) {
                if (response.status === _const.HTTP_STATUS_TOO_MANY_REQUESTS) {
                    throw new utils.DynamicError('sendRawTransaction - mempool api rate limit exceeded');
                }
                const error = yield response.text();
                walletConnectorCore.logger.debug(`sendRawTransaction - response not ok: ${JSON.stringify(error)}`);
                throw new utils.DynamicError('sendRawTransaction - failed to send transaction');
            }
            // this endpoint returns the transaction ID
            return response.text();
        });
    }
    getProvider() {
        var _a;
        return (_a = this.bitcoinProviderHelper) === null || _a === void 0 ? void 0 : _a.getProvider();
    }
    setConnectedAccountWithAddresses(_a) {
        return _tslib.__awaiter(this, arguments, void 0, function* ({ mainAddress, ordinalsAddress, paymentAddress, active, }) {
            if (!mainAddress) {
                return;
            }
            const additionalAddresses = [];
            if (ordinalsAddress) {
                additionalAddresses.push({
                    address: ordinalsAddress.address,
                    publicKey: ordinalsAddress.publicKey,
                    type: sdkApiCore.WalletAddressType.Ordinals,
                });
            }
            if (paymentAddress) {
                additionalAddresses.push({
                    address: paymentAddress.address,
                    publicKey: paymentAddress.publicKey,
                    type: sdkApiCore.WalletAddressType.Payment,
                });
            }
            this.cache.setConnectedAccount(mainAddress, {
                active,
                additionalAddresses,
            });
        });
    }
    setupEventListeners() {
        const provider = this.getProvider();
        if (!(provider === null || provider === void 0 ? void 0 : provider.on)) {
            return;
        }
        const { handleAccountChange, handleChainChange, handleDisconnect } = walletConnectorCore.eventListenerHandlers(this);
        const handleBitcoinAccountChange = (accounts) => _tslib.__awaiter(this, void 0, void 0, function* () {
            let connectedAccounts = accounts;
            let ordinalsAccount, paymentAccount;
            // if accounts is an array of objects, we need to parse them to return only addresses
            // since ordinals is the main address we use, we should return it as the first address
            if (typeof accounts[0] === 'object') {
                connectedAccounts = accounts
                    .sort((account) => account.purpose === satsConnect.AddressPurpose.Ordinals ? -1 : 1)
                    .map((account) => account.address);
                [ordinalsAccount, paymentAccount] = connectedAccounts;
            }
            const currentConnectedAccounts = yield this.getConnectedAccountsFromCache();
            // don't do anything if the connected accounts haven't changed
            // or if the account change request is the same as previous request
            if (currentConnectedAccounts[0] === connectedAccounts[0] ||
                this.isSameAccountChangeRequest(connectedAccounts[0])) {
                return;
            }
            // set the last account change request with the from and to addresses
            // to ensure that the requests are not duplicated
            this.setLastAccountChangeRequest(connectedAccounts[0]);
            if (ordinalsAccount || paymentAccount) {
                this.setConnectedAccountWithAddresses({
                    active: true,
                    mainAddress: ordinalsAccount !== null && ordinalsAccount !== void 0 ? ordinalsAccount : paymentAccount,
                    ordinalsAddress: ordinalsAccount,
                    paymentAddress: paymentAccount,
                });
            }
            handleAccountChange(connectedAccounts);
        });
        provider.on('accountsChanged', handleBitcoinAccountChange);
        provider.on('networkChanged', handleChainChange);
        provider.on('disconnect', handleDisconnect);
        const tearDownEventListeners = () => {
            const provider = this.getProvider();
            if (!(provider === null || provider === void 0 ? void 0 : provider.removeListener)) {
                return;
            }
            provider.removeListener('accountsChanged', handleBitcoinAccountChange);
            provider.removeListener('networkChanged', handleChainChange);
            provider.removeListener('disconnect', handleDisconnect);
        };
        this.teardownEventListeners = tearDownEventListeners;
    }
    setVerifiedCredentials(verifiedCredentials) {
        this.verifiedCredentials = verifiedCredentials;
    }
    isLedgerAddress(address) {
        return utils.isLedgerAddressViaVerifiedCredentials(address, this.verifiedCredentials);
    }
}

exports.BitcoinWalletConnector = BitcoinWalletConnector;
