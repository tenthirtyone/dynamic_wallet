'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../_virtual/_tslib.cjs');
var utils = require('@dynamic-labs/utils');

class BitcoinLocalStorageCache {
    constructor(key) {
        this.CONNECTED_ACCOUNTS_KEY = `bitcoin_${key}_connectedAccounts`;
        this.LAST_BALANCE_KEY = `bitcoin_${key}_lastBalance`;
    }
    getActiveAccount() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const connectedAccounts = yield utils.getItemAsync(this.CONNECTED_ACCOUNTS_KEY);
            if (!connectedAccounts) {
                return;
            }
            const activeAddress = Object.keys(connectedAccounts).find((key) => connectedAccounts[key].active);
            if (!activeAddress) {
                return;
            }
            return {
                additionalAddresses: connectedAccounts[activeAddress].additionalAddresses,
                address: activeAddress,
            };
        });
    }
    getConnectedAccounts() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const connectedAccounts = yield utils.getItemAsync(this.CONNECTED_ACCOUNTS_KEY);
            return connectedAccounts;
        });
    }
    getConnectedAccount(address) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const connectedAccounts = yield utils.getItemAsync(this.CONNECTED_ACCOUNTS_KEY);
            return connectedAccounts === null || connectedAccounts === void 0 ? void 0 : connectedAccounts[address];
        });
    }
    setConnectedAccount(addess, account) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            let connectedAccounts = yield utils.getItemAsync(this.CONNECTED_ACCOUNTS_KEY);
            if (!connectedAccounts) {
                connectedAccounts = {};
            }
            // if current account is active, reset all other accounts to inactive
            if (account.active) {
                Object.keys(connectedAccounts).forEach((key) => {
                    if (connectedAccounts) {
                        connectedAccounts[key].active = false;
                    }
                });
            }
            // add new account to map or override existing one
            connectedAccounts[addess] = account;
            return utils.setItemAsync(this.CONNECTED_ACCOUNTS_KEY, connectedAccounts);
        });
    }
    clearConnectedAcccounts() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            return utils.removeItemAsync(this.CONNECTED_ACCOUNTS_KEY);
        });
    }
    getLastBalance() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            return utils.getItemAsync(this.LAST_BALANCE_KEY);
        });
    }
    setLastBalance(balance) {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            return utils.setItemAsync(this.LAST_BALANCE_KEY, balance);
        });
    }
    clearLastBalance() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            return utils.removeItemAsync(this.LAST_BALANCE_KEY);
        });
    }
}

exports.BitcoinLocalStorageCache = BitcoinLocalStorageCache;
