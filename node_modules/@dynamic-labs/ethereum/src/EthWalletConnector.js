'use client'
import { __awaiter } from '../_virtual/_tslib.js';
import { formatEther } from 'viem';
import { toAccount } from 'viem/accounts';
import { WalletConnectorBase } from '@dynamic-labs/wallet-connector-core';
import { parseEvmNetworks, retryableFn, FALLBACK_UNDEFINED, DynamicError, getOrMapViemChain } from '@dynamic-labs/utils';
import { findEvmNetwork } from './utils/findEvmNetwork.js';
import { getNameservice } from './utils/getNameservice.js';

class EthWalletConnector extends WalletConnectorBase {
    getPublicClient() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            const networkId = (_a = (yield this.getNetwork())) !== null && _a !== void 0 ? _a : 1;
            if (this.evmNetworks.length === 0) {
                return undefined;
            }
            const configurations = {
                cosmos: [],
                evm: this.evmNetworks,
                solana: [],
                starknet: undefined,
            };
            return (_c = (_b = this.chainRpcProviders) === null || _b === void 0 ? void 0 : _b.getEvmProviderByChainId(configurations, networkId)) === null || _c === void 0 ? void 0 : _c.provider;
        });
    }
    constructor(props) {
        var _a;
        super(props);
        this.evmNetworkRpcMap = () => this.evmNetworks.reduce((acc, network) => {
            var _a;
            [acc[network.chainId]] = ((_a = network === null || network === void 0 ? void 0 : network.privateCustomerRpcUrls) === null || _a === void 0 ? void 0 : _a.length)
                ? network.privateCustomerRpcUrls
                : network.rpcUrls;
            return acc;
        }, {});
        this.evmNetworks = parseEvmNetworks(props.evmNetworks);
        this.chainRpcProviders = props.chainRpcProviders;
        (_a = this.chainRpcProviders) === null || _a === void 0 ? void 0 : _a.registerEvmProviders();
    }
    getNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = this.getWalletClient();
            if (!this.supportsNetworkSwitching || !provider) {
                return Promise.resolve(undefined);
            }
            return retryableFn(provider.getChainId, {
                fallbackValue: FALLBACK_UNDEFINED,
                /**
                 * The timeout is set to 1 second because the getChainId method
                 * takes around 500ms to resolve on Brave. If the timeout is not set
                 * it will use 100ms by default and the method will fail.
                 * QNTM-815
                 */
                timeoutMs: 1000,
            });
        });
    }
    getNameService() {
        return __awaiter(this, void 0, void 0, function* () {
            const [[address], rpcProvider] = yield Promise.all([
                this.getConnectedAccounts(),
                this.getPublicClient(),
            ]);
            if (!address || !rpcProvider) {
                return;
            }
            return getNameservice({ address, rpcProvider });
        });
    }
    getSigner() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getWalletClient();
        });
    }
    getBalance() {
        return __awaiter(this, void 0, void 0, function* () {
            // This is equivalent to getSigner().getAddress() but does not crash
            // if the signer is not available
            const [address] = yield this.getConnectedAccounts();
            if (!address)
                return;
            const client = yield this.getPublicClient();
            const result = yield (client === null || client === void 0 ? void 0 : client.getBalance({
                address: address,
            }));
            if (!result && result !== BigInt(0))
                return;
            return formatEther(result);
        });
    }
    supportsNetworkSwitching() {
        return true;
    }
    switchNetwork(_a) {
        return __awaiter(this, arguments, void 0, function* ({ networkName, networkChainId, }) {
            const network = findEvmNetwork({
                chainId: networkChainId,
                name: networkName,
                networks: this.evmNetworks,
            });
            if (!network) {
                throw new DynamicError(`Could not find network mapping for chain ${networkName ? networkName : networkChainId}`);
            }
            if (!this.supportsNetworkSwitching()) {
                throw new DynamicError('Network switching is not supported');
            }
            const provider = this.getWalletClient();
            if (!provider) {
                throw new DynamicError('Provider not found');
            }
            return this.providerSwitchNetwork({ network, provider });
        });
    }
    getConnectedAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = this.getWalletClient();
            if (!provider)
                return [];
            const addresses = yield retryableFn(provider.getAddresses, {
                fallbackValue: [],
                timeoutMs: 500,
            });
            if (addresses.length) {
                this.setActiveAccount(addresses[0]);
            }
            return addresses;
        });
    }
    providerSwitchNetwork(_a) {
        return __awaiter(this, arguments, void 0, function* ({ network, provider, }) {
            var _b, _c, _d, _e;
            const { chainId } = network;
            const currentNetworkId = yield this.getNetwork();
            if (currentNetworkId && currentNetworkId === chainId) {
                return;
            }
            try {
                if (!this.supportsNetworkSwitching()) {
                    throw new DynamicError('Network switching is not supported');
                }
                yield provider.switchChain(getOrMapViemChain(network));
                if (this.key === 'magiceden') {
                    const newChainId = yield provider.getChainId();
                    this.emit('chainChange', { chain: newChainId.toString() });
                }
            }
            catch (error) {
                // we need to check for unrecognized chain error first because it also contains 'rejected' in message
                if (error.code === 4902 ||
                    ((_b = error.message) === null || _b === void 0 ? void 0 : _b.includes('Unrecognized chain')) ||
                    // https://github.com/MetaMask/metamask-mobile/issues/3312#issuecomment-1065923294
                    ((_d = (_c = error.data) === null || _c === void 0 ? void 0 : _c.orginalError) === null || _d === void 0 ? void 0 : _d.code) === 4902) {
                    // error code indicates the chain has not been added yet
                    // https://docs.metamask.io/guide/rpc-api.html#usage-with-wallet-switchethereumchain
                    return this.providerAddNetwork({ network, provider });
                }
                else if (((_e = error.message) === null || _e === void 0 ? void 0 : _e.includes('rejected')) ||
                    (typeof error === 'string' && error.includes('rejected'))) {
                    throw new DynamicError("User rejected the wallet's request to switch network");
                }
                else {
                    throw error;
                }
            }
        });
    }
    providerAddNetwork(_a) {
        return __awaiter(this, arguments, void 0, function* ({ network, provider, }) {
            var _b;
            try {
                return yield provider.addChain({ chain: getOrMapViemChain(network) });
            }
            catch (error) {
                if (((_b = error.message) === null || _b === void 0 ? void 0 : _b.includes('rejected')) ||
                    (typeof error === 'string' && error.includes('rejected'))) {
                    throw new DynamicError("User rejected the wallet's request to add network");
                }
                else {
                    throw error;
                }
            }
        });
    }
    setActiveAccount(account) {
        this.activeAccount = account ? toAccount(account) : undefined;
    }
    getActiveAccount() {
        return this.activeAccount;
    }
}

export { EthWalletConnector };
