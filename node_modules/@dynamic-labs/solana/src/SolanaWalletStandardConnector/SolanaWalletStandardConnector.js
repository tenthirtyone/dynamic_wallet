'use client'
import { __awaiter } from '../../_virtual/_tslib.js';
import { getWallets } from '@wallet-standard/app';
import { SolWalletConnector } from '../solWalletConnector.js';
import { createSolanaSignerFromWalletStandard } from './utils/createSolanaSignerFromWalletStandard/createSolanaSignerFromWalletStandard.js';

const encoder = new TextEncoder();
class SolanaWalletStandardConnector extends SolWalletConnector {
    constructor(props) {
        super(props);
        this.connectedChain = 'SOL';
        this.supportedChains = ['SOL'];
    }
    get wallet() {
        const walletStandard = SolanaWalletStandardConnector.getWallet(this.walletBook, this.key);
        if (!walletStandard) {
            throw new Error('Wallet not found');
        }
        return walletStandard;
    }
    get walletFeatures() {
        return this.wallet.features;
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.walletFeatures['standard:connect'].connect();
        });
    }
    endSession() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.walletFeatures['standard:disconnect'].disconnect();
        });
    }
    isInstalledOnBrowser() {
        return true;
    }
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.connect();
            const [address] = yield this.getConnectedAccounts();
            return address;
        });
    }
    getConnectedAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            const addresses = this.wallet.accounts.map((account) => account.address);
            return addresses;
        });
    }
    signMessage(messageToSign) {
        return __awaiter(this, void 0, void 0, function* () {
            const signer = yield this.getSigner();
            if (!signer) {
                throw new Error('Signer not found');
            }
            const message = encoder.encode(messageToSign);
            const signature = yield signer.signMessage(message);
            if (!(signature instanceof Uint8Array)) {
                throw new Error('Signature not found');
            }
            return Buffer.from(signature).toString('base64');
        });
    }
    getSigner() {
        return __awaiter(this, void 0, void 0, function* () {
            const { wallet } = this;
            return createSolanaSignerFromWalletStandard(wallet, this);
        });
    }
    static getWallet(walletBook, walletKey) {
        var _a, _b;
        const wallets = getWallets().get();
        const injectedConfig = (_a = walletBook.wallets[walletKey].injectedConfig) === null || _a === void 0 ? void 0 : _a.find((config) => config.chain === 'sol');
        if (!injectedConfig)
            return;
        const { features } = (_b = injectedConfig.walletStandard) !== null && _b !== void 0 ? _b : {};
        if (!features)
            return;
        const wallet = wallets.find((wallet) => {
            var _a;
            const isNameMatch = wallet.name === ((_a = injectedConfig.walletStandard) === null || _a === void 0 ? void 0 : _a.name);
            if (!isNameMatch)
                return false;
            const hasFeatures = features.reduce((hasAllFeatures, key) => {
                const walletFeatures = Object.keys(wallet.features);
                if (!hasAllFeatures)
                    return false;
                return walletFeatures.includes(key);
            }, true);
            return hasFeatures;
        });
        return wallet;
    }
}

export { SolanaWalletStandardConnector };
