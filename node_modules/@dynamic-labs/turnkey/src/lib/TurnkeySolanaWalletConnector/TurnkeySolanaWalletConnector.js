'use client'
import { __awaiter, __rest } from '../../../_virtual/_tslib.js';
import { PublicKey, LAMPORTS_PER_SOL } from '@solana/web3.js';
import { WebauthnStamper } from '@turnkey/webauthn-stamper';
import { TurnkeyClient } from '@turnkey/http';
import { TurnkeySigner } from '@turnkey/solana';
import { IframeStamper } from '@turnkey/iframe-stamper';
import { ProviderChain } from '@dynamic-labs/rpc-provider-solana';
import { DynamicError, getTLD, PlatformService, bufferToBase64 } from '@dynamic-labs/utils';
import { SolanaUiTransaction } from '@dynamic-labs/solana-utils';
import { TurnkeyWalletConnectorBase } from '../TurnkeyWalletConnectorBase/TurnkeyWalletConnectorBase.js';
import { findTurnkeyVerifiedCredential } from '../utils/findTurnkeyVerifiedCredential/findTurnkeyVerifiedCredential.js';
import '../utils/convertAttestationTransports/convertAttestationTransports.js';
import { createSolanaConnection } from '../utils/createSolanaConnection/createSolanaConnection.js';
import { decodeTransaction, summarizeTransactionDecodedData } from '../utils/transactionDecoder/transactionDecoder.js';
import { TURNKEY_API_BASE_URL } from '../constants.js';
import { getGenesisHashLSKey } from '../utils/getGenesisHashLSKey/getGenesisHashLSKey.js';
import { PasskeyService } from '../utils/PasskeyService/PasskeyService.js';
import { TurnkeySolanaSigner } from './TurnkeySolanaSigner.js';

class TurnkeySolanaWalletConnector extends TurnkeyWalletConnectorBase {
    constructor(nameAndKey, props) {
        var _a;
        super(nameAndKey, props);
        // Public fields
        this.connectedChain = 'SOL';
        this.supportedChains = ['SOL'];
        this.verifiedCredentialChain = 'solana';
        this.solNetworks = props.solNetworks;
        this.walletUiUtils = props.walletUiUtils;
        this._turnkeyAccount = undefined;
        this._connectionClient = undefined;
        this.chainRpcProviders = props.chainRpcProviders;
        (_a = this.chainRpcProviders) === null || _a === void 0 ? void 0 : _a.registerSolanaProviders();
        this.__turnkeyClient = this.getTurnkeyClient();
    }
    getRpcUrl() {
        var _a;
        const [network] = this.solNetworks;
        if (!network) {
            throw new DynamicError('No enabled networks');
        }
        return ((_a = network.privateCustomerRpcUrls) === null || _a === void 0 ? void 0 : _a[0]) || network.rpcUrls[0];
    }
    getConnection(commitmentOrConfig) {
        if (!this._connectionClient) {
            const rpcUrl = this.getRpcUrl();
            if (!rpcUrl)
                throw new DynamicError('No rpcUrl');
            this._connectionClient = createSolanaConnection(rpcUrl, commitmentOrConfig);
        }
        return this._connectionClient;
    }
    getWalletClient() {
        return this.getConnection();
    }
    getNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            const connection = this.getConnection();
            let genesisHash = localStorage.getItem(getGenesisHashLSKey(connection.rpcEndpoint));
            if (!genesisHash) {
                genesisHash = yield connection.getGenesisHash();
                localStorage.setItem(getGenesisHashLSKey(connection.rpcEndpoint), genesisHash);
            }
            genesisHash = genesisHash.substring(0, 32);
            // see: https://github.com/ChainAgnostic/namespaces/blob/main/solana/caip2.md
            if (genesisHash === '5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp') {
                return 'mainnet';
            }
            else if (genesisHash === 'EtWTRABZaYq6iMfeYKouRu166VU2xqa1') {
                return 'devnet';
            }
            else {
                return 'testnet';
            }
        });
    }
    getPublicClient() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            if (this.solNetworks.length === 0)
                return;
            const configurations = {
                cosmos: [],
                evm: undefined,
                solana: this.solNetworks,
                starknet: undefined,
            };
            return (_b = (_a = this.chainRpcProviders) === null || _a === void 0 ? void 0 : _a.getSolanaRpcProviderByChainId(configurations, '101')) === null || _b === void 0 ? void 0 : _b.provider;
        });
    }
    supportsNetworkSwitching() {
        return false;
    }
    setVerifiedCredentials(verifiedCredentials) {
        const turnkeyVerifiedCredential = findTurnkeyVerifiedCredential(verifiedCredentials, ProviderChain.SOLANA);
        const didTurnkeyVerifiedCredentialsChanged = JSON.stringify(this.verifiedCredential) !==
            JSON.stringify(turnkeyVerifiedCredential);
        if (!didTurnkeyVerifiedCredentialsChanged) {
            return;
        }
        this.verifiedCredential = turnkeyVerifiedCredential;
        this.refreshTurnkeyAccount();
    }
    getAccount() {
        return this.turnkeyAddress;
    }
    endSession() {
        return __awaiter(this, void 0, void 0, function* () {
            localStorage.removeItem(getGenesisHashLSKey(this.getRpcUrl()));
        });
    }
    refreshTurnkeyAccount() {
        return __awaiter(this, void 0, void 0, function* () {
            this._turnkeyAccount = undefined;
            return this.getTurnkeyAccount();
        });
    }
    getTurnkeyClient() {
        var _a;
        let rpId = getTLD();
        if (!rpId) {
            rpId = PlatformService.getHostname();
        }
        const stamper = PasskeyService.createWebauthnStamper({
            rpId,
        });
        this.__turnkeyClient =
            (_a = this.getAuthenticatorHandler().client) !== null && _a !== void 0 ? _a : new TurnkeyClient({
                baseUrl: TURNKEY_API_BASE_URL,
            }, stamper);
        return this.__turnkeyClient;
    }
    createTurnkeyAccount(_a) {
        return __awaiter(this, arguments, void 0, function* ({ organizationId, }) {
            const turnkeyClient = this.getTurnkeyClient();
            const signer = new TurnkeySigner({ client: turnkeyClient, organizationId });
            return signer;
        });
    }
    getTurnkeyAccount() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            if (this._turnkeyAccount &&
                ((this.getAuthenticatorHandler().recoveryType === 'passkey' &&
                    ((_a = this.__turnkeyClient) === null || _a === void 0 ? void 0 : _a.stamper) instanceof WebauthnStamper) ||
                    (this.getAuthenticatorHandler().recoveryType === 'email' &&
                        ((_b = this.__turnkeyClient) === null || _b === void 0 ? void 0 : _b.stamper) instanceof IframeStamper)) &&
                this.__turnkeyClient === this.getAuthenticatorHandler().client) {
                return this._turnkeyAccount;
            }
            const { turnkeySubOrganizationId } = (_c = this.walletProperties) !== null && _c !== void 0 ? _c : {};
            const { address } = (_d = this.verifiedCredential) !== null && _d !== void 0 ? _d : {};
            if (!turnkeySubOrganizationId || !address) {
                return;
            }
            this._turnkeyAccount = yield this.createTurnkeyAccount({
                organizationId: turnkeySubOrganizationId,
            });
            return this._turnkeyAccount;
        });
    }
    getSigner() {
        return __awaiter(this, void 0, void 0, function* () {
            return new TurnkeySolanaSigner({ walletConnector: this });
        });
    }
    getBalance() {
        return __awaiter(this, void 0, void 0, function* () {
            const address = this.getAccount();
            if (!address) {
                return undefined;
            }
            const connectionClient = this.getConnection();
            const publicKey = new PublicKey(address);
            const balance = yield connectionClient.getBalance(publicKey);
            const solBalance = this.lamportsToSol(balance);
            return solBalance.toString();
        });
    }
    signMessage(messageToSign) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.turnkeyAddress) {
                throw new DynamicError('No turnkey account');
            }
            const address = this.turnkeyAddress;
            const signedMessage = yield this.walletUiUtils.signMessage({
                handler: () => __awaiter(this, void 0, void 0, function* () {
                    var _a;
                    const enc = new TextEncoder();
                    const encodedMessage = enc.encode(messageToSign);
                    const signedMessageRaw = yield ((_a = (yield this.getTurnkeyAccount())) === null || _a === void 0 ? void 0 : _a.signMessage(encodedMessage, address));
                    return bufferToBase64(signedMessageRaw || Buffer.from([]));
                }),
                message: messageToSign,
            });
            return signedMessage;
        });
    }
    signTransaction(_a) {
        return __awaiter(this, arguments, void 0, function* ({ transaction, }) {
            const account = yield this.getTurnkeyAccount();
            const address = this.turnkeyAddress;
            if (!account || !address) {
                throw new Error('No turnkey account');
            }
            yield account.addSignature(transaction, address);
            return Buffer.from(transaction.serialize());
        });
    }
    internalSignAndSendTransaction(transaction, options) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            if (!this.turnkeyAddress)
                throw new DynamicError('Solana wallet not found');
            const currentConnection = this.getConnection('confirmed');
            const blockhash = yield currentConnection.getLatestBlockhash();
            if ('version' in transaction) {
                transaction.message.recentBlockhash =
                    blockhash.blockhash;
            }
            else {
                transaction.recentBlockhash = blockhash.blockhash;
                transaction.feePayer =
                    (_a = transaction.feePayer) !== null && _a !== void 0 ? _a : new PublicKey(this.turnkeyAddress);
            }
            const signedTransaction = yield this.signTransaction({ transaction });
            const signature = yield currentConnection.sendRawTransaction(signedTransaction, options);
            const transactionConfirmationStrategy = {
                blockhash: blockhash.blockhash,
                lastValidBlockHeight: blockhash.lastValidBlockHeight,
                signature,
            };
            const result = yield (currentConnection === null || currentConnection === void 0 ? void 0 : currentConnection.confirmTransaction(transactionConfirmationStrategy));
            return ((_b = result === null || result === void 0 ? void 0 : result.value) === null || _b === void 0 ? void 0 : _b.err) ? JSON.stringify(result.value.err) : signature;
        });
    }
    signAndSendTransaction(transaction, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.turnkeyAddress)
                throw new DynamicError('Solana wallet not found');
            const transactionsData = yield decodeTransaction(transaction, this.getConnection());
            if (!(transactionsData === null || transactionsData === void 0 ? void 0 : transactionsData.length)) {
                throw new DynamicError('Incorrectly formatted transaction instructions');
            }
            const { to, value } = summarizeTransactionDecodedData(transactionsData);
            const uiTransaction = new SolanaUiTransaction({
                connection: this.getConnection(),
                from: this.turnkeyAddress,
                onSubmit: () => __awaiter(this, void 0, void 0, function* () { return this.internalSignAndSendTransaction(transaction, options); }),
                originalTransaction: transaction,
            });
            uiTransaction.to = to;
            uiTransaction.value = value;
            return this.walletUiUtils.sendTransaction(this, uiTransaction);
        });
    }
    sendTransaction(transaction_1, connection_1) {
        return __awaiter(this, arguments, void 0, function* (transaction, connection, options = {}) {
            var _a;
            if (!this.turnkeyAddress)
                throw new DynamicError('Solana wallet not found');
            if (!transaction || !connection) {
                throw new DynamicError('Transaction and connection are required');
            }
            const { signers } = options, sendOptions = __rest(options, ["signers"]);
            const blockhash = yield connection.getLatestBlockhash({
                commitment: options.preflightCommitment,
                minContextSlot: options.minContextSlot,
            });
            if ('version' in transaction) {
                (signers === null || signers === void 0 ? void 0 : signers.length) && transaction.sign(signers);
            }
            else {
                transaction.feePayer =
                    transaction.feePayer || new PublicKey(this.turnkeyAddress);
                transaction.recentBlockhash =
                    transaction.recentBlockhash || blockhash.blockhash;
                (signers === null || signers === void 0 ? void 0 : signers.length) && transaction.partialSign(...signers);
            }
            sendOptions.preflightCommitment =
                sendOptions.preflightCommitment || connection.commitment;
            const signature = yield connection.sendRawTransaction(transaction.serialize(), options);
            const transactionConfirmationStrategy = {
                blockhash: blockhash.blockhash,
                lastValidBlockHeight: blockhash.lastValidBlockHeight,
                signature,
            };
            const result = yield (connection === null || connection === void 0 ? void 0 : connection.confirmTransaction(transactionConfirmationStrategy));
            return ((_a = result === null || result === void 0 ? void 0 : result.value) === null || _a === void 0 ? void 0 : _a.err) ? JSON.stringify(result.value.err) : signature;
        });
    }
    lamportsToSol(lamports) {
        return lamports / LAMPORTS_PER_SOL;
    }
    createUiTransaction(from) {
        return __awaiter(this, void 0, void 0, function* () {
            return new SolanaUiTransaction({
                connection: this.getConnection(),
                from,
                onSubmit: (transaction) => __awaiter(this, void 0, void 0, function* () { return this.internalSignAndSendTransaction(transaction); }),
            });
        });
    }
}

export { TurnkeySolanaWalletConnector };
