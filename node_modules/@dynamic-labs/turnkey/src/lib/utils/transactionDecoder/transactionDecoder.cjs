'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../../../_virtual/_tslib.cjs');
var web3_js = require('@solana/web3.js');
var utils = require('@dynamic-labs/utils');

const decodeTransaction = (transaction, connection) => _tslib.__awaiter(void 0, void 0, void 0, function* () {
    var _a;
    if (!transaction) {
        throw new utils.DynamicError('Transaction is required');
    }
    let decodedInstructions = [];
    if ('version' in transaction) {
        const lookupTableAddresses = transaction.message.addressTableLookups.map((lookup) => new web3_js.PublicKey(lookup.accountKey));
        // for NON simple sol transfers we need to fetch the lookup table accounts
        if (lookupTableAddresses.length > 0) {
            const lookupTables = yield Promise.all(lookupTableAddresses.map((address) => connection.getAddressLookupTable(address)));
            const lookupTableAccounts = lookupTables
                .filter((result) => result !== null)
                .map((result) => result.value);
            if (lookupTableAccounts.length > 0) {
                decodedInstructions = web3_js.TransactionMessage.decompile(transaction.message, {
                    addressLookupTableAccounts: lookupTableAccounts,
                }).instructions;
            }
        }
        else {
            decodedInstructions = web3_js.TransactionMessage.decompile(transaction.message).instructions;
        }
    }
    else if (!transaction.instructions) {
        decodedInstructions = (_a = web3_js.Transaction.from(Buffer.from(transaction.serialize()))) === null || _a === void 0 ? void 0 : _a.instructions;
    }
    else {
        decodedInstructions = transaction.instructions;
    }
    if (!(decodedInstructions === null || decodedInstructions === void 0 ? void 0 : decodedInstructions.length)) {
        throw new utils.DynamicError('Bad formatted instruction');
    }
    // filter only solana system instructions, i.e SOL transfers
    return decodedInstructions
        .filter((instruction) => instruction.programId.equals(web3_js.SystemProgram.programId))
        .map((decodedInstruction) => {
        const decodedTransferInstruction = web3_js.SystemInstruction.decodeTransfer(decodedInstruction);
        return {
            from: decodedTransferInstruction === null || decodedTransferInstruction === void 0 ? void 0 : decodedTransferInstruction.fromPubkey.toBase58(),
            to: decodedTransferInstruction === null || decodedTransferInstruction === void 0 ? void 0 : decodedTransferInstruction.toPubkey.toBase58(),
            value: decodedTransferInstruction === null || decodedTransferInstruction === void 0 ? void 0 : decodedTransferInstruction.lamports,
        };
    });
});
const summarizeTransactionDecodedData = (transactionsData) => {
    const recipients = new Set();
    let transferTotalValue = BigInt(0);
    transactionsData.forEach((transactionData) => {
        recipients.add(transactionData.to);
        transferTotalValue += transactionData.value;
    });
    const to = recipients.size === 1
        ? recipients.values().next().value
        : 'dyn_send_transaction.multiple_recipients';
    return { to, value: transferTotalValue };
};

exports.decodeTransaction = decodeTransaction;
exports.summarizeTransactionDecodedData = summarizeTransactionDecodedData;
