'use client'
import { __awaiter } from '../../../../_virtual/_tslib.js';
import { PublicKey, TransactionMessage, Transaction, SystemProgram, SystemInstruction } from '@solana/web3.js';
import { DynamicError } from '@dynamic-labs/utils';

const decodeTransaction = (transaction, connection) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    if (!transaction) {
        throw new DynamicError('Transaction is required');
    }
    let decodedInstructions = [];
    if ('version' in transaction) {
        const lookupTableAddresses = transaction.message.addressTableLookups.map((lookup) => new PublicKey(lookup.accountKey));
        // for NON simple sol transfers we need to fetch the lookup table accounts
        if (lookupTableAddresses.length > 0) {
            const lookupTables = yield Promise.all(lookupTableAddresses.map((address) => connection.getAddressLookupTable(address)));
            const lookupTableAccounts = lookupTables
                .filter((result) => result !== null)
                .map((result) => result.value);
            if (lookupTableAccounts.length > 0) {
                decodedInstructions = TransactionMessage.decompile(transaction.message, {
                    addressLookupTableAccounts: lookupTableAccounts,
                }).instructions;
            }
        }
        else {
            decodedInstructions = TransactionMessage.decompile(transaction.message).instructions;
        }
    }
    else if (!transaction.instructions) {
        decodedInstructions = (_a = Transaction.from(Buffer.from(transaction.serialize()))) === null || _a === void 0 ? void 0 : _a.instructions;
    }
    else {
        decodedInstructions = transaction.instructions;
    }
    if (!(decodedInstructions === null || decodedInstructions === void 0 ? void 0 : decodedInstructions.length)) {
        throw new DynamicError('Bad formatted instruction');
    }
    // filter only solana system instructions, i.e SOL transfers
    return decodedInstructions
        .filter((instruction) => instruction.programId.equals(SystemProgram.programId))
        .map((decodedInstruction) => {
        const decodedTransferInstruction = SystemInstruction.decodeTransfer(decodedInstruction);
        return {
            from: decodedTransferInstruction === null || decodedTransferInstruction === void 0 ? void 0 : decodedTransferInstruction.fromPubkey.toBase58(),
            to: decodedTransferInstruction === null || decodedTransferInstruction === void 0 ? void 0 : decodedTransferInstruction.toPubkey.toBase58(),
            value: decodedTransferInstruction === null || decodedTransferInstruction === void 0 ? void 0 : decodedTransferInstruction.lamports,
        };
    });
});
const summarizeTransactionDecodedData = (transactionsData) => {
    const recipients = new Set();
    let transferTotalValue = BigInt(0);
    transactionsData.forEach((transactionData) => {
        recipients.add(transactionData.to);
        transferTotalValue += transactionData.value;
    });
    const to = recipients.size === 1
        ? recipients.values().next().value
        : 'dyn_send_transaction.multiple_recipients';
    return { to, value: transferTotalValue };
};

export { decodeTransaction, summarizeTransactionDecodedData };
