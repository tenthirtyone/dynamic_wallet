'use client'
import { __awaiter } from '../../../_virtual/_tslib.js';
import { Transaction, PublicKey, SystemProgram } from '@solana/web3.js';
import { formatNumberText } from '@dynamic-labs/utils';

const LAMPORTS_PER_SOL = 1000000000;
class SolanaUiTransaction {
    constructor({ onSubmit, from, connection, originalTransaction, }) {
        this.chain = 'SOL';
        this.data = undefined;
        this.fee = { gas: undefined };
        this.from = from;
        this.onSubmit = onSubmit;
        this.connection = connection;
        this.originalTransaction = originalTransaction;
    }
    parse(input) {
        return BigInt(parseFloat(input) * LAMPORTS_PER_SOL);
    }
    format(value, { precision } = {}) {
        return formatNumberText(String(parseFloat(value.toString()) / LAMPORTS_PER_SOL), {
            precision,
        });
    }
    submit() {
        const sendTransaction = this.createTransaction();
        return this.onSubmit(sendTransaction);
    }
    getBalance() {
        return __awaiter(this, void 0, void 0, function* () {
            const publicKey = new PublicKey(this.from);
            const balance = yield this.connection.getBalance(publicKey);
            return BigInt(balance);
        });
    }
    validateAddressFormat(address) {
        if (address === 'dyn_send_transaction.multiple_recipients') {
            return true;
        }
        return /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(address);
    }
    fetchFee() {
        return __awaiter(this, void 0, void 0, function* () {
            const transaction = this.createTransactionSafe();
            if (!transaction) {
                return;
            }
            let compiledMessage;
            const { blockhash } = yield this.connection.getLatestBlockhash();
            if ('version' in transaction) {
                transaction.message.recentBlockhash = blockhash;
                compiledMessage = transaction.message;
            }
            else {
                transaction.recentBlockhash = blockhash;
                transaction.feePayer = new PublicKey(this.from);
                compiledMessage = transaction.compileMessage();
            }
            if (!compiledMessage) {
                throw new Error('Invalid transaction');
            }
            const res = yield this.connection.getFeeForMessage(compiledMessage);
            this.fee.gas = res.value ? BigInt(res.value) : undefined;
        });
    }
    createTransaction() {
        const { value, to } = this;
        if (!to) {
            throw new Error('Destination is required');
        }
        if (this.originalTransaction) {
            return this.originalTransaction;
        }
        const sendTransaction = new Transaction();
        const fromPubkey = new PublicKey(this.from);
        const toPubkey = new PublicKey(to);
        const lamports = value !== null && value !== void 0 ? value : 0;
        sendTransaction.add(SystemProgram.transfer({
            fromPubkey,
            lamports,
            toPubkey,
        }));
        return sendTransaction;
    }
    createTransactionSafe() {
        try {
            return this.createTransaction();
        }
        catch (error) {
            return undefined;
        }
    }
}

export { LAMPORTS_PER_SOL, SolanaUiTransaction };
